plot(specs, select=spp=='pbicalc', col='blue')
plot(specs, select=spp=='pbicalc', col='grey')
plot(specs, select=spp=='pavomut', col='grey')
plot(specs, select=spp=='pavomut', col='red')
plot(specs, select=spp=='pavomut', col='pink')
plot(specs, select=spp=='pavomut', col=spec2rgb(specs))
spp
plot(specs, 12:17)
plot(specs[,12])
plot(specs[,13])
plot(specs[,14])
plot(specs[,15])
plot(specs[,16])
plot(specs[,17])
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, select])# set xlimif (is.null(xlim))  xlim <- range(wl)else xlim <- xlim# coloringif (length(col)==1)  col <- rep(col, ncol(specs))else if (is.character(col))  col <- col[select]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, col = col[1],       lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
plot(specs, 13:18, col='blue')
plot(specs, 11:16, col='blue')
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set xlimif (is.null(xlim))  xlim <- range(wl)else xlim <- xlim# coloringif (length(col)==1)  col <- rep(col, ncol(specs))else if (is.character(col))  col <- col[select]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, col = col[1],       lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
plot(specs, 12:17, col='blue')
plot(specs, 2, col='blue')
plot(specs, 3, col='blue')
plot(specs, 2:5, col='blue')
plot(specs, c(2,12,36), col='blue')
plot(specs, c(2,12,36), col=c('red', 'blue', 'green'))
class(c('red','blue'))
plot(specs, c(2,12,36), col=rainbow(10))
plot(specs, c(2,12,36), col=rainbow(1))
rainbow(3)
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set xlimif (is.null(xlim))  xlim <- range(wl)else xlim <- xlim# coloringif (length(col)==1)  col <- rep(col, ncol(specs))else if (is.character(col)&length(col)==ncol(specs))  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select]else  col <- col#
# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, col = col[1],       lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
plot(specs, c(2,12,36), col=rainbow(2))
Convert reflectance spectrum to rgb values# http://www.cs.rit.edu/~ncs/color/t_spectr.html# D65 white point# ref for color matching functions?# TODO: references dataset in sys bundlespec2rgb <- function(specs) {#
wl_index <- which(names(specs)=='wl')if (length(wl_index > 0)){  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])    } else {    stop('No wavelengths supplied; no default')    }specs <- as.matrix(specs)sens <- read.csv("/Users/chad/Documents/pavo/R_temp/spec.csv", row.names=1)  P2 <- sapply(1:ncol(specs), function(x) specs[, x] / sum(specs[, x]))  # normalize to sum of 1#P2 <- specs / 100# Calculate human quantum catches (??)X <- apply(sens[1:401, 9] * P2, 2, sum)Y <- apply(sens[1:401, 10] * P2, 2, sum)Z <- apply(sens[1:401, 11] * P2, 2, sum)XYZ <- rbind(X, Y, Z)xyzmat <- rbind(c(3.240479, -1.537150, -0.498535),								c(-0.969256, 1.875992, 0.041556),								c(0.055648, -0.204043, 1.057311))XYZ <- sapply(1:ncol(XYZ), function(x) XYZ[, x] / sum(XYZ[, x]))rgb1 <- sapply(1:ncol(XYZ), function(x) xyzmat%*%as.matrix(XYZ[, x]))# normalization functionsrgb1[rgb1 < 0] <- 0rgb1[rgb1 > 1] <- 1colrs <- rgb(r=rgb1[1,], g=rgb1[2,], b=rgb1[3,])class(colrs) <- c('spec2rgb', 'character')colrs}
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set xlimif (is.null(xlim))  xlim <- range(wl)else xlim <- xlim# coloringif (length(col)==1)  col <- rep(col, ncol(specs))else if (class(col)=='spec2rgb')  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select]else  col <- col#
# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, col = col[1],       lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
plot(specs, c(2,12,36), col=rainbow(3))
plot(specs, c(2,12,36), col=rainbow(4))
plot(specs, c(2,12,36), col=rainbow(5))
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set xlimif (is.null(xlim))  xlim <- range(wl)else xlim <- xlim# coloringif (length(col)==1)  col <- rep(col, ncol(specs))else if (class(col)=='spec2rgb')  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, col = col[1],       lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set xlimif (is.null(xlim))  xlim <- range(wl)else xlim <- xlim# coloringif (length(col)==1)  col <- rep(col, ncol(specs))else if (class(col)=='spec2rgb')  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, col = col[1],       lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set xlimif (is.null(xlim))  xlim <- range(wl)else xlim <- xlim# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (class(col)=='spec2rgb')  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, col = col[1],       lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set xlimif (is.null(xlim))  xlim <- range(wl)else xlim <- xlim# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (class(col)=='spec2rgb')  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]#else {#  col <- col#}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, col = col[1],       lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
colr <- spec2rgb(specs)
class(colr)
if(any(class(colr)))
if (any(class(colr)=='spec2rgb')) 'hi'
if (any(class(colr)=='spec2rgb')) 'hi' else 'bye'
if (any(class(colr)=='character')) 'hi' else 'bye'
if (any(class(colr)=='chaacter')) 'hi' else 'bye'
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set xlimif (is.null(xlim))  xlim <- range(wl)else xlim <- xlim# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (any(class(col)=='spec2rgb'))  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, col = col[1],       lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
plot(specs, c(2,12,36), col=spec2rgb(specs))
plot(specs, c(3,12,36), col=spec2rgb(specs))
plot(specs, c(4,12,36), col=spec2rgb(specs))
plot(specs, c(5,12,36), col=spec2rgb(specs))
plot(specs, c(6,12,36), col=spec2rgb(specs))
plot(specs, c(6,9,36), col=spec2rgb(specs))
plot(specs, c(6,9,32), col=spec2rgb(specs))
range(specs)
range(specs[,-1])
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, ylim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set limitsif (is.null(xlim))  xlim <- range(wl)else xlim <- xlimif (is.null(ylim))  ylim <- range(specs)else ylim <- ylim#
# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (any(class(col)=='spec2rgb'))  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, ylim = ylim,       col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, ylim = c(0, sum(ym)), type='l', xlab = 'Wavelength (nm)',       ylab = 'Reflectance (arb. units)', xlim = xlim, ylim = ylim, col = col[1],        lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim, ylim = ylim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, ylim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set limitsif (is.null(xlim))  xlim <- range(wl)else xlim <- xlimif (is.null(ylim))  ylim <- range(specs)else ylim <- ylim#
# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (any(class(col)=='spec2rgb'))  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, ylim = ylim,       col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, type='l', xlim = xlim, ylim = c(0, sum(ym)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (arb. units)', col = col[1],        lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim, ylim = ylim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, ylim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set limitsif (is.null(xlim))  xlim <- range(wl)else xlim <- xlimif (is.null(ylim))  ylim <- range(specs)else ylim <- ylim#
# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (any(class(col)=='spec2rgb'))  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', ylim = ylim, # c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, ylim = ylim,       col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, type='l', xlim = xlim, ylim = c(0, sum(ym)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (arb. units)', col = col[1],        lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim, ylim = ylim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
Pavo function to plot groups of spectra# select is 'picked' spectra; can be a numeric vector or factor (e.g., sex=='male')# for heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot# TODO: give warning if don't supply wavelengthsplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, ylim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set limitsif (is.null(xlim))  xlim <- range(wl)else xlim <- xlimif (is.null(ylim))  ylim <- range(specs)else ylim <- ylim#
# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (any(class(col)=='spec2rgb'))  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', # c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, ylim = ylim,       col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, type='l', xlim = xlim, ylim = c(0, sum(ym)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (arb. units)', col = col[1],        lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim, ylim = ylim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
plot(specs, c(6,9,32), col=spec2rgb(specs), ylim=c(0,100))
plot(specs, c(6,9,32), col=spec2rgb(specs), ylim=c(0,25))
plot(specs, c(6,9,32), col=spec2rgb(specs), ylim=NULL)
plot(specs, c(6,9,32), col=spec2rgb(specs), ylim=NULL, lwd=3)
plot(specs, c(6,9,32), col=spec2rgb(specs), lwd=3)
plot(specs, c(6,15,32), col=spec2rgb(specs), lwd=3)
plot(specs, c(6,15:18,32), col=spec2rgb(specs), lwd=3)
plot(procspec(specs, c('min','max')), c(6,15:18,32), col=spec2rgb(specs), lwd=3)
plot(procspec(specs, c('max')), c(6,15:18,32), col=spec2rgb(specs), lwd=3)
plot(procspec(specs, c('sum')), c(6,15:18,32), col=spec2rgb(specs), lwd=3)
plot(procspec(specs, 'smooth', span=.25), c(6,15:18,32), col=spec2rgb(specs), lwd=3)
Pavo function to plot groups of spectra# 'select' sets which spectra to plot. Can be a numeric vector or factor (e.g., sex=='male')# For heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# 'col' sets the color of the spec curves. User can either provide a single color, a vector of colors or a spec2rgb object (giving colors based on human visual system)# TODO: add argument for 'buffer' region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plotplot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, ylim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set limitsif (is.null(xlim))  xlim <- range(wl)else xlim <- xlimif (is.null(ylim))  ylim <- range(specs)else ylim <- ylim#
# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (any(class(col)=='spec2rgb'))  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', # c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, ylim = ylim,       col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, type='l', xlim = xlim, ylim = c(0, sum(ym)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (arb. units)', col = col[1],        lwd = lwd, yaxt='n')  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim, ylim = ylim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
plot(procspec(specs, 'smooth', span=.25), c(6,15:18,32), col=spec2rgb(specs), lwd=3, type='s')
Pavo function to plot groups of spectra# 'select' sets which spectra to plot. Can be a numeric vector or factor (e.g., sex=='male')# For heatmaps, 'by' is a vector describing numeric values across which spectra are varying# 'n' is number of bins to interpolate 'varying' over# 'col' sets the color of the spec curves. User can either provide a single color, a vector of colors or a spec2rgb object (giving colors based on human visual system)# TODO: add argument for padding region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot (ideas anyone?)plot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, col = heat.colors(25), n = 100,                        xlim = NULL, ylim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set limitsif (is.null(xlim))  xlim <- range(wl)else xlim <- xlimif (is.null(ylim))  ylim <- range(specs)else ylim <- ylim#
# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (any(class(col)=='spec2rgb'))  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', # c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, ylim = ylim,       col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, type='l', xlim = xlim, ylim = c(0, sum(ym)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (arb. units)', col = col[1],        lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim, ylim = ylim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}# Testing zone for new plotting function#plot(rspecs, select=c(2,14,9), type='h', by=c(10,20,30))#plot(witu, select=2:7, type='h', varying=seq(10,60,by=10))#plot(rspecs, select=c(2,14,9,12,13,19), type='o', by=c(10,20,30))#plot(rspecs, select=2:4, type='s')#rspecs2 <- procspec(rspecs, f='stretch')#plot(rspecs2, select=2:8, type='o')#plot(rspecs, by=spp, type='g', rows=3)
plot(specs, select=spp=='afropavo', col=spec2rgb(specs))
plot(specs, select=spp=='pbicalc', col=spec2rgb(specs))
plot(specs, select=spp=='pbicalc', col='black')
plot(specs[,2])
plot(spec[2])
specs[2]
plot(specs[2])
plot(specs[,2:4])
plot(specs[,2:5])
plot(specs[,5:7])
plot(specs, 2:4)
plot(specs, 2:4, col=spec2rgb(specs))
plot(specs, 15:20, col=spec2rgb(specs))
plot(specs, 15:20, col=spec2rgb(specs), type='g')
plot(specs, 15:20, col=spec2rgb(specs), type='s')
plot(specs, 15:20, col=spec2rgb(specs), type='h')
plot(specs, 15:20, col=heat.colors(25), type='h')
plot(specs, 15:20, col=heat.colors(25), type='h', varying=c(10,20,30,35,36,50))
head(witu)
plot(witu, 15:20, col=heat.colors(25), type='h', varying=c(10,20,30,35,36,50))
plot(witu, col=heat.colors(25), varying=c(10,20,30,35,36,50))
class(witu)
plot.rspec(witu)
plot(witu, type='h')
plot.rspec(witu, type='h')
plot.rspec(witu, 2:8, type='h')
plot.rspec(witu, 2:8, type='h', varying=seq(10,80,by=10))
plot.rspec(witu, 2:8, type='h', varying=seq(10,70,by=10))
plot.rspec(witu, 2:8, type='h', varying=seq(10,70,by=10), ylab="xx")
plot(witu[,2])
plot(witu[,2]~witu[,1])
FWHM(specs[,1], specs[,2])
FWHM(witu[,2])
head(wl,1)
which(wl==300)
which(wl==700)
apply(specs, 1, max)
apply(specs, 2, which(specs==25))
sapply(1:ncol(specs), function(x)which(specs[x]==300))
sapply(1:ncol(specs), function(x)which(specs[x]==.5))
apply(specs, 2, max)
Yi <- apply(specs, 2, max)Yj <- apply(specs, 2, min)
Yi/Yj
which(specs==Yi)
sapply(1:ncol(specs2), function(x) which(specs[x]==Yi))
sapply(1:ncol(specs), function(x) which(specs[x]==Yi))
sapply(1:nrow(specs), function(x) which(specs[x]==Yi))
sapply(1:ncol(specs), function(x) which(specs[,x]==Yi))
sapply(1:ncol(specs), function(x) which(specs[x,]==Yi))
sapply(1:ncol(specs), function(x) which(specs[, x]==Yi[x]))
rm(Yi,Yj)
require(roxygen)
detach(package:roxygen)
require(roxygen2)
apropos("roxy")
?roxygenise
?getspec
?tcs
?plot.phylo
sens <- read.csv("/Users/chad/Documents/pavo/R_temp/ciexyz31.csv", head=F)
approx(sens$V1, sens$V2, xout=c(300:700))
head(cie)
sapply(2:4, function(x) approx(sens[,1], sens[,i], xout=c(300:700)$y)
)
sapply(2:4, function(x) approx(sens[,1], sens[,x], xout=c(300:700)$y))
sapply(2:4, function(x) approx(x=sens[,1], y=sens[,x], xout=c(300:700)$y))
sapply(2:4, function(x) approx(x=sens[,1], y=sens[,x], xout=c(300:700)))
sapply(2:4, function(x) approx(x=sens[,1], y=sens[,x], xout=c(300:700))$y)
sens <- sapply(2:4, function(x) approx(x=sens[,1], y=sens[,x], xout=c(300:700))$y)
is.na(sens)
sens[is.na(sens)]
sens[is.na(sens)] <- 0
head(sens)
sens
' Spectrum to rgb color conversion#'#' Calculates rgb values from spectra based on human color matching functions#'#' @param specs (required) An rspec object of spectral data with columns as spectra. #' #' @return a character vector of class \code{spec2rgb} consisting of hexadecimal color values#' for passing to further plotting functions.#' @export#' @examples \dontrun{#' #INCLUDE EXAMPLE}#' @author Chad Eliason \email{cme16@@zips.uakron.edu}#' @references TODO Stoddard, M. C., & Prum, R. O. (2008). Evolution of avian plumage color in a tetrahedral color space: A phylogenetic analysis of new world buntings. The American Naturalist, 171(6), 755-776.#' @references Endler, J. A., & Mielke, P. (2005). Comparing entire colour patterns as birds see them. Biological Journal Of The Linnean Society, 86(4), 405431.#' @references CIE. (1932). Commission Internationale de lclairage Proceedings, 1931. Cambridge: Cambridge University Press.#
# Convert reflectance spectrum to rgb values# http://www.cs.rit.edu/~ncs/color/t_spectr.html# D65 white point# ref for color matching functions?# TODO: references dataset in sys bundlespec2rgb <- function(specs) {#
wl_index <- which(names(specs)=='wl')if (length(wl_index > 0)){  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])    } else {    stop('No wavelengths supplied; no default')    }specs <- as.matrix(specs)#sens <- read.csv("/Users/chad/Documents/pavo/R_temp/spec.csv", row.names=1)  sens <- read.csv("/Users/chad/Documents/pavo/R_temp/ciexyz31.csv", head=F)sens <- sapply(2:4, function(x) approx(x=sens[,1], y=sens[,x], xout=c(300:700))$y)sens[is.na(sens)] <- 0  # convert NAs to zeroes for UV wavelengthsP2 <- sapply(1:ncol(specs), function(x) specs[, x] / sum(specs[, x]))  # normalize to sum of 1#P2 <- specs / 100# Calculate human quantum catches (??)X <- apply(sens[, 1] * P2, 2, sum)Y <- apply(sens[, 2] * P2, 2, sum)Z <- apply(sens[, 3] * P2, 2, sum)XYZ <- rbind(X, Y, Z)xyzmat <- rbind(c(3.240479, -1.537150, -0.498535),								c(-0.969256, 1.875992, 0.041556),								c(0.055648, -0.204043, 1.057311))XYZ <- sapply(1:ncol(XYZ), function(x) XYZ[, x] / sum(XYZ[, x]))rgb1 <- sapply(1:ncol(XYZ), function(x) xyzmat%*%as.matrix(XYZ[, x]))# normalization functionsrgb1[rgb1 < 0] <- 0rgb1[rgb1 > 1] <- 1colrs <- rgb(r=rgb1[1,], g=rgb1[2,], b=rgb1[3,])class(colrs) <- c('spec2rgb', 'character')colrs}
spec2rgb(specs)
require(lattice)
?xyplot
?plot
apropos("rogye")
apropos("roxyg")
?roxygen
rd_roclet()
' Plot spectra#'#' Plots reflectance spectra in different arrangements.#'#' @param specs (required) Quantum catch color data. Can be either the result#' from \code{vismodel} or independently calculated data (in the form of a data frame#' with four columns, representing the avian cones).#' @param select specification of which spectra to plot. Can be a numeric vector or #' factor (e.g., \code{sex=='male'})#' @param type what type of plot should be drawn. Possibilities are: #' \itemize{#'  \item overlay for plotting multiple spectra in a single panel with a common y-axis#'  \item stack for plotting multiple spectra in a vertical arrangement#'  \item heatmap for plotting reflectance values by wavelength and a third variable #'        (\code{varying})#'  \item grid for plotting spectra in separate panels#' }#' @param cols the number of columns used in \code{grid} plots#' @param varying # a numeric vector giving values for third variable used in #' \code{heatplot}#' @param n number of bins with which to interpolate \code{varying}#' @param col color of the spec curves. User can either provide a single color, a vector #' of colors (e.g., code\{heat.colors(25)} for heaplots) or a \code{spec2rgb} object. #' For the latter, picking spectra with \code{select} will also subset the color vector.#' @param xlim a numeric vector giving the lower an upper limits for the x-axis#' @param ylim a numeric vector giving the lower an upper limits for the y-axis#' Does not apply for \code{type = 'heatmap'}.#' @param lwd width of lines #' @export#' @examples \dontrun{#' #INCLUDE EXAMPLE}#' @author Chad Eliason \email{cme16@@zips.uakron.edu}# Pavo function to plot groups of spectra# TODO: add argument for padding region between specs in stack plot# TODO: add labels to curves along y-axis for stacked plot (ideas anyone?)# TODO: figure out way to label y-axis in heatplot (ideas?)plot.rspec <- function(specs, select = NULL, type = c('overlay', 'stack', 'heatmap',                            'grid'), cols = 2, varying = NULL, n = 100, col = 'black',                        xlim = NULL, ylim = NULL, lwd = 1) {old.par <- par(no.readonly = TRUE)  # all par settings that could be settype <- match.arg(type)# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])# set limitsif (is.null(xlim))  xlim <- range(wl)else xlim <- xlimif (is.null(ylim))  ylim <- range(specs)else ylim <- ylim#
# coloringif (length(col)==1)  col <- rep(col, ncol(specs))if (any(class(col)=='spec2rgb'))  # this messes up when you give a normal color string; need to look for # or something about hex.  col <- col[select-1]else {  col <- col}# heat plotif (type=='heatmap') {  if (is.null(varying)) {     varying <- 1:ncol(specs)    print("No varying vector supplied; using arbitrary values")  }    varying <- varying  dat <- sapply(1:nrow(specs), function(z){approx(x = varying, y = specs[z, ],                 n = n)$y})  image(x = wl, y = approx(varying, n = n)$y, z = t(dat), col = col,        xlab = 'Wavelength (nm)', xlim = xlim)}# overlay different spec curvesif (type=='overlay') {  plot(specs[, 1]~wl, type = 'l', # c(min(specs), max(specs)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (%)', xlim = xlim, ylim = ylim,       col = col[1], lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))      lines(specs[, i]~wl, col=col[i], lwd = lwd)  }}# stack curves along y-axisif (type=='stack') {  specs2 <- sapply(1:ncol(specs), function(z){specs[, z] - min(specs[, z])})  ym <- apply(specs2, 2, max)    plot(specs2[, 1]~wl, type='l', xlim = xlim, ylim = c(0, sum(ym)),        xlab = 'Wavelength (nm)', ylab = 'Reflectance (arb. units)', col = col[1],        lwd = lwd)  if (ncol(specs)>1) {    for (i in 2:ncol(specs))       lines((specs2[, i] + cumsum(ym)[i - 1])~wl, col = col[i], lwd = lwd)    }}# arrange plots in a gridif (type=='grid') {  rows <- ceiling(ncol(specs)/cols)  par(mfrow = c(rows, cols))  for (i in 1:ncol(specs)) {    plot(specs[, i]~wl, type = 'l', main = names(specs)[i],         xlab = "Wavelength (nm)", ylab = "Reflectance (%)", xlim = xlim, ylim = ylim,         col = col[i], lwd = lwd)  # fix ylim  }}par(old.par)  # return settings to previous}
plot.rspec
rd_roclet(plot.rspec)
require(devtools)
?document
?loess.smooth
spec
sp
sp <- specs
class(sp)
d <- specs
d
class(d)
rm(sp)
plot(d)
plot(d, col=spec2rgb(d))
plot(d, col=heat.colors(50))
plot(d, col=heat.colors(30))
plot(d, col=heat.colors(40))
plot(d, col='green')
plot(d, 2:5, col='green')
plot(d, 2:5, col=spec2rgb(d))
plot(d, 2:5, col=spec2rgb(d), 's')
FWHM(d)
specs
specs = rspec object# select = which curve to measure (if multiple, plots one at a time)# bounds - pick left/right bound of window surrounding peak of interest# returns hue, FWHM, peak reflectanceFWHM <- function(specs, select = NULL, bounds = c(300, 700), plot = T) {old.par <- par(no.readonly = TRUE)  # all par settings that could be set# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])wlrange <- bounds[1]:bounds[2]specs2 <- specs[(which(wl==bounds[1])):(which(wl==bounds[2])), ]  # ok?Yi <- apply(specs2, 2, max)  # max reflsYj <- apply(specs2, 2, min)  # min reflsXi <- sapply(1:ncol(specs2), function(x) which(specs2[, x]==Yi[x]))  # lambda_max index#####TEST#########################sapply(1:ncol(specs), function(x) specs[, x]fsthalf <- specs2[1:Xi]sndhalf <- specs2[Xi + 1:length(specs2)]halfmax <- (Yi + Yj) / 2  # reflectance midpointfstHM <- which.min(abs(fsthalf - halfmax))sndHM <- which.min(abs(sndhalf - halfmax))Xa <- wl[fstHM]Xb <- wl[Xi+sndHM]if (plot==T) {  plot(specs~wl, type = 'l')  abline(v = wl[specs2==Yi], col = "red")  abline(h = halfmax, col = "red")  abline(v = Xa, col = "red", lty = 2)  abline(v = Xb, col = "red", lty = 2)  hue <- wl[Xi]  Xc <- min(hue - Xa, Xb - hue, na.rm = T)  return(list(l = Xa, r = Xb, fwhm = Xb - Xa, hue = hue, b3 = Yi))}else {	hue <- wl[Xi]	Xc <- min(hue - Xa, Xb - hue, na.rm = T)	return(c(l = Xa, r = Xb, fwhm = Xb - Xa, hue = hue, b3 = Yi))}}#
##THIS FUNCTION TAKES A GIVEN VECTOR OF VALUES AND DETERMINES THE INDICES AT WHICH PEAKS OCCUR. SPAN SETS THE SENSITIVITY (RANGE OF VALUES TO LOOK OVER). TAKEN FROM BRIAN RIPLEY (ONLINE MAILING LIST)peaks <- function(series,span=3) {   z <- embed(series, span)   s <- span%/%2   v <- max.col(z)==1 + s   result <- c(rep(FALSE, s), v)   result <- result[1:(length(result) - s)]   result }
c(300,700)
c(300,700)[1]
c(300,700)[2]
do
10+10
wl==c(300,700)[1]
which(wl==c(300,700)[1])
which(wl==c(300,700)[2])
specs = rspec object# select = which curve to measure (if multiple, plots one at a time)# bounds - pick left/right bound of window surrounding peak of interest# returns hue, FWHM, peak reflectanceFWHM <- function(specs, select = NULL, bounds = c(300, 700), plot = T) {old.par <- par(no.readonly = TRUE)  # all par settings that could be set# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])wlrange <- bounds[1]:bounds[2]specs2 <- specs[(which(wl==bounds[1])):(which(wl==bounds[2])), ]  # working wl rangeYi <- apply(specs2, 2, max)  # max reflsYj <- apply(specs2, 2, min)  # min reflsXi <- sapply(1:ncol(specs2), function(x) which(specs2[, x]==Yi[x]))  # lambda_max index#sapply(1:ncol(specs), function(x) specs[, x]fsthalf <- specs2[1:Xi]sndhalf <- specs2[Xi + 1:length(specs2)]halfmax <- (Yi + Yj) / 2  # reflectance midpointfstHM <- which.min(abs(fsthalf - halfmax))sndHM <- which.min(abs(sndhalf - halfmax))Xa <- wl[fstHM]Xb <- wl[Xi+sndHM]if (plot==T) {  plot(specs~wl, type = 'l')  abline(v = wl[specs2==Yi], col = "red")  abline(h = halfmax, col = "red")  abline(v = Xa, col = "red", lty = 2)  abline(v = Xb, col = "red", lty = 2)  hue <- wl[Xi]  Xc <- min(hue - Xa, Xb - hue, na.rm = T)  return(list(l = Xa, r = Xb, fwhm = Xb - Xa, hue = hue, b3 = Yi))}else {	hue <- wl[Xi]	Xc <- min(hue - Xa, Xb - hue, na.rm = T)	return(c(l = Xa, r = Xb, fwhm = Xb - Xa, hue = hue, b3 = Yi))}}
FWHM(specs, select=2)
FWHM(specs, select=2:4)
wl_index <- which(names(specs)=='wl')
wl_index
wl <- specs[,wl_index]
wl
bounds <- c(400,500)
bounds
wlrange <- bounds[1]:bounds[2]
wlrange
specs[,2][(which(wl==bounds[1])):(which(wl==bounds[2])), ]
specs[2][(which(wl==bounds[1])):(which(wl==bounds[2])), ]
specs2 <- specs[2][(which(wl==bounds[1])):(which(wl==bounds[2])), ]
apply(specs2, 2, max)
max(specs2)
specs = rspec object# select = which curve to measure (if multiple, plots one at a time)# bounds - pick left/right bound of window surrounding peak of interest# returns hue, FWHM, peak reflectanceFWHM <- function(specs, select = NULL, bounds = c(300, 700), plot = T) {old.par <- par(no.readonly = TRUE)  # all par settings that could be set# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])wlrange <- bounds[1]:bounds[2]specs2 <- specs[(which(wl==bounds[1])):(which(wl==bounds[2])), ]  # working wl rangeif (ncol(specs2)==1) {  Yi <- max(specs2)  # max refls  Yj <- min(specs2)  # min refls  Xi <- which(specs2==Yi))  # lambda_max index}else {  Yi <- apply(specs2, 2, max)  # max refls  Yj <- apply(specs2, 2, min)  # min refls  Xi <- sapply(1:ncol(specs2), function(x) which(specs2[, x]==Yi[x]))  # lambda_max index}#sapply(1:ncol(specs), function(x) specs[, x]fsthalf <- specs2[1:Xi]sndhalf <- specs2[Xi + 1:length(specs2)]halfmax <- (Yi + Yj) / 2  # reflectance midpointfstHM <- which.min(abs(fsthalf - halfmax))sndHM <- which.min(abs(sndhalf - halfmax))Xa <- wl[fstHM]Xb <- wl[Xi+sndHM]if (plot==T) {  plot(specs~wl, type = 'l')  abline(v = wl[specs2==Yi], col = "red")  abline(h = halfmax, col = "red")  abline(v = Xa, col = "red", lty = 2)  abline(v = Xb, col = "red", lty = 2)  hue <- wl[Xi]  Xc <- min(hue - Xa, Xb - hue, na.rm = T)  return(list(l = Xa, r = Xb, fwhm = Xb - Xa, hue = hue, b3 = Yi))}else {	hue <- wl[Xi]	Xc <- min(hue - Xa, Xb - hue, na.rm = T)	return(c(l = Xa, r = Xb, fwhm = Xb - Xa, hue = hue, b3 = Yi))}}
specs = rspec object# select = which curve to measure (if multiple, plots one at a time)# bounds - pick left/right bound of window surrounding peak of interest# returns hue, FWHM, peak reflectanceFWHM <- function(specs, select = NULL, bounds = c(300, 700), plot = T) {old.par <- par(no.readonly = TRUE)  # all par settings that could be set# make wavelength vectorwl_index <- which(names(specs)=='wl')if (length(wl_index > 0)) {  wl <- specs[, wl_index]  specs <- as.data.frame(specs[, -wl_index])} else if (length(wl_index==0)) {  wl <- 1:nrow(specs)  specs <- as.data.frame(specs)  warning('No wavelengths provided; using arbitrary index values')}# subset based on indexing vectorif (is.logical(select))  select <- which(select=='TRUE')else if (is.null(select))  select <- 1:ncol(specs)specs <- as.data.frame(specs[, (select-1)])wlrange <- bounds[1]:bounds[2]specs2 <- specs[(which(wl==bounds[1])):(which(wl==bounds[2])), ]  # working wl rangeif (ncol(specs2)==1) {  Yi <- max(specs2)  # max refls  Yj <- min(specs2)  # min refls  Xi <- which(specs2==Yi)  # lambda_max index}else {  Yi <- apply(specs2, 2, max)  # max refls  Yj <- apply(specs2, 2, min)  # min refls  Xi <- sapply(1:ncol(specs2), function(x) which(specs2[, x]==Yi[x]))  # lambda_max index}#sapply(1:ncol(specs), function(x) specs[, x]fsthalf <- specs2[1:Xi]sndhalf <- specs2[Xi + 1:length(specs2)]halfmax <- (Yi + Yj) / 2  # reflectance midpointfstHM <- which.min(abs(fsthalf - halfmax))sndHM <- which.min(abs(sndhalf - halfmax))Xa <- wl[fstHM]Xb <- wl[Xi+sndHM]if (plot==T) {  plot(specs~wl, type = 'l')  abline(v = wl[specs2==Yi], col = "red")  abline(h = halfmax, col = "red")  abline(v = Xa, col = "red", lty = 2)  abline(v = Xb, col = "red", lty = 2)  hue <- wl[Xi]  Xc <- min(hue - Xa, Xb - hue, na.rm = T)  return(list(l = Xa, r = Xb, fwhm = Xb - Xa, hue = hue, b3 = Yi))}else {	hue <- wl[Xi]	Xc <- min(hue - Xa, Xb - hue, na.rm = T)	return(c(l = Xa, r = Xb, fwhm = Xb - Xa, hue = hue, b3 = Yi))}}
FWHM(specs[,2])
FWHM(specs[2])
FWHM(specs, 2)
FWHM(specs, 2:4)
specs2
min(specs2)
Yi <- max(specs2)
Yj <- min(specs2)
Xi <- which(specs2==Yi)
Yi
Yj
Xi
names(specs)
specs['wl']
head(specs)
specs['PEMPHANUM0009']
dev_mode()
dev_mode(F)
install_github('pavo', 'rmaia')
install.packages("/Users/chad/Documents/pavo", type='source', repos=NULL)
?plot.rspec
?pavo
plot.rspec(specs, col=spec2rgb(specs))
class(specs) <- c("rspec", "data.frame")
plot(specs, col=spec2rgb(specs))
rm(plot.rspec)
rm(agg)
rm(procspec)
plot(specs, col=spec2rgb(specs), type='s')
plot(specs)
plot(specs, type='l')
plot.rspec(specs)
rm(list=ls())
install.packages("/Users/chad/Documents/pavo", type='source', repos=NULL)require(pavo)
ls()
rm(specs)
detach(package:pavo)
require(pavo)
specs <- getspec("~/Documents/School/PhD/Projects/Polyplectron/data/2012-05-10/pheasants_200-1000nm", ext="ttt")
class(specs)
getspec
