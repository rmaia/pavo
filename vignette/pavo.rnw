\documentclass{article}

% Definitions
\newcommand{\pavo}{{\tt pavo}}  % you can use \pavo{} to print pavo in code text formatting
\newcommand{\code}[1]{{\tt #1}}  % text formate for code
\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{float}
\usepackage{authblk}
\usepackage[usenames,dvipsnames]{color}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[utf8]{inputenc}

\usepackage{geometry} 
\geometry{letterpaper, textwidth=5.5in, textheight=8.5in, marginparsep=7pt, marginparwidth=.6in}
%\setlength\parindent{0in}

% define colors
\hypersetup{
  colorlinks,
  citecolor=violet,
  linkcolor=black,
  urlcolor=MidnightBlue
  }
\renewcommand{\thefootnote}{\textcolor{Gray}{\arabic{footnote}}}


\begin{document}


\SweaveOpts{concordance=TRUE, prefix.string=pavo}

<<echo=FALSE, results=hide>>=
library(pavo)
ps.options(pointsize=12)
options(width=60)
@

\title{\pavo{}: {\bf P}erceptual {\bf A}nalysis, {\bf V}isualization and {\bf O}rganization of Spectral Color Data in R}
\author[1]{Rafael Maia}
\author[2]{Paul-Pierre Bitton}
\author[1]{Chad Eliason}
\affil[1]{Integrated Bioscience PhD Program, University of Akron, Akron OH}
\affil[2]{Department of Biological Sciences, University of Windsor, Windsor ON}
\maketitle

\addtolength{\parskip}{-.08in}
\tableofcontents
\addtolength{\parskip}{.08in}

\section{Introduction}

\pavo{} is an R package developed with the goal of establishing a flexible and integrated  workflow
for working with spectral color data. It includes functions that take advantage of new data classes
in order to work seamlessly from importing raw data to visualization and  analysis.

Although \pavo{} deals largely with spectral reflectance data from bird feathers, it is meant  to be
applicable for a range of taxa and applications. It provides flexible ways to input spectral data
from a variety of equipment manufacturers, process these data, extract variables  and produce
publication-quality graphics.

\pavo{} was written with the following workflow in mind:

% numbered list of things
\begin{enumerate}
\item {\bf Organize} spectral data by inputting files, processing spectra (e.g., to remove
noise, negative values, smooth curves, etc.)
\item {\bf Analyze} the resulting files, either using typical tristimulus color variables (hue,
saturation, brightness) or using visual models based on perceptual data from the taxon of 
interest.
\item {\bf Visualize} the output, with multiple options provided for exploratory analyses.
\end{enumerate}

Below we will show the main functions in the package in an example workflow. The development
version of \pavo{} can be found on \href{https://github.com/rmaia/pavo}{github}.

\section{Dataset Description}

The data used in this example is available from 
\href{https://github.com/rmaia/pavo/blob/master/vignette_data/vignette_data.zip}
{github by clicking here}\footnote{in case you can't click the printed version you have:\\ 
\url{https://github.com/rmaia/pavo/blob/master/vignette_data/vignette_data.zip}}. 
You can download and extract it to follow the vignette.

The data consists of reflectance spectra obtained using Avantes equipment and software from  seven
bird species: Northern Cardinal (\emph{Cardinalis cardinalis}), Wattled Jacana (\emph{Jaca na
jacana}), Baltimore Oriole (\emph{Icterus galbula}), Peach-fronted Parakeet (\emph{Aratinga
aurea}), American Robin (\emph{Turdus migratorius}),  and Sayaca Tanager  (\emph{Thraupis sayaca}).
Several individuals were measured (sample size varies by species), and  3 spectra were collected
from each individual.

The samples do not have the same sample sizes and have additional peculiarities that should
emphasize the flexibility \pavo{} offers, as we'll see below.

\section{Organizing and Processing Spectral Data}

\subsection{Importing Data}

The first thing we need to do is import the spectral data into R using the funciton
\code{getspec()}. Since the spectra were obtained using Avantes software, we will need to  specify
that the files have the "\code{.ttt}" extension. Further, the data is organized in  subdirectories
for each species. \code{getspec} does recursive sampling, and may include the  names of the
subdirectories in the spectra name if desired. A final issue with the data is that  it was collected
using a computer with international numbering input, which means it uses commas  instead of periods
as a decimal separator. We can specify that in the function call.

I have downloaded the file and placed it in a directory called 
``\nolinkurl{/github/pavo/vignette_data}''. By default, \code{getspec} will search for files in 
the current folder, but a different one can be specified:

<<>>=
specs <- getspec("~/github/pavo/vignette_data/", ext="ttt", decimal=",", 
                 subdir=T, subdir.names=F)
specs[1:10,1:4]
dim(specs) #data has 214 spectra, from 300 to 700 nm
@

When \pavo{} imports spectra, it creates an object of class \code{rspec}, which inherits attributes
from the \code{data.frame} class:

<<>>=
is.rspec(specs)
@

If you already have multiple spectra in a single data frame that you'd like to use with \pavo{} 
functions, you can use the command \code{as.rspec} to convert it to an rspec object. The 
function will attempt to identify the wavelength variable or, if it doesn't have one, it can be 
specified in the function call.

\subsection{Processing Data}

\subsubsection{Averaging Spectra}

As previously described, our data constitutes of multiple individuals, and each was measured 
three times, as is common in order to avoid measurement bias. A good way to visualize the 
repeatability of our measurements is to plot the spectra of each individual separately. The 
function \code{explorespec} provides an easy way of doing so. You may specify the number of 
spectra to be plotted in the same panel using the argument \code{specreps}, and the function 
will adjust the number of panels per page accordingly. We will exemplify this function using 
only the 12 cardinal individuals measured:

<<label=explorespecfig, fig=TRUE, include=FALSE>>=
explorespec(specs[,1:37], specreps=3) 
# 36 spectra plus the first (wl) column
@

\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=6in, height=7in]{pavo-explorespecfig}
\end{center}
\caption{Result from \code{explorespec}, showing the three measurements for each individual in separate panels}
\label{figure:explorespec}
\end{figure}

\clearpage{}

So our first step would be to take the average of each of these three measurements in order to 
obtain average individual spectra to be used in further analyses. The function \code{aggspec} 
does this. The \code{by} argument can be either a number (specifying how many specs should be 
averaged for each new sample) or a vector specifying the identities of the spectra to be 
combined (see below):

<<>>=
mspecs <- aggspec(specs, by=3, FXN=mean)
mspecs[1:5, 1:4]
dim(mspecs) #data now has 72 spectra, one for each individual
@

Now we'll use the \code{aggspec} function again, but this time to take the average spectrum for 
each species. However, each species has a different number of samples, so we can't use the 
\code{by} argument as before. Instead we will use regular expressions to create a species name 
vector by removing the numbers that identify individual spectra:

<<>>=
# create a vector with species identity names
spp <- gsub('\\.[0-9].*$','',names(mspecs))[-1]
table(spp)
@

Instead, we are going to use the \code{spp} vector we created to tell the \code{aggspec} 
function how to average the spectra in \code{mspec}:

<<label=exploresppmeans, fig=TRUE, include=FALSE>>=
sppspec <- aggspec(mspecs, by=spp, FXN=mean)
sppspec[1:5, ]
explorespec(sppspec, 6)
@

\begin{figure}[H]
\begin{center}
\includegraphics{pavo-exploresppmeans}
\end{center}
\caption{Result from \code{explorespec} for species means}
\label{figure:sppmeans}
\end{figure}


 \subsubsection{Normalizing and Smoothing Spectra}

Data obtained from spectrometers often requires further processing before analysis and/or 
publication. For example, electrical noise can produce unwanted "spikes" in reflectance curves. The 
\pavo{} function \code{procspec} can handle a variety of processing techniques. For example, the 
reflectance curve from the parakeet is noisy in the short (300-400 nm) and long (650-700 
nm) wavelength ranges (Figure \ref{figure:specsmooth}, black line). To eliminate this noise, we can 
use the \code{opt} argument in \code{procspec} to smooth data using local regression, as implemented 
by the \code{loess.smooth} function in \code{R} (Figure \ref{figure:specsmooth}, red line).

<<label=specsmooth,fig=TRUE,include=FALSE,results=hide>>=
spec.sm <- procspec(sppspec, opt='smooth')
plot(sppspec[, 5]~sppspec[, 1], type='l', xlab="Wavelength (nm)", ylab="Reflectance (%)")
lines(spec.sm[, 5]~sppspec[, 1], col='red')
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{pavo-specsmooth}
\end{center}
\caption{Result for raw (black line) and smoothed (red line) reflectance data for the parakeet.}
\label{figure:specsmooth}
\end{figure}

We can also try some other normalizations. Note that the user can specify multiple processing 
options that will be applied sequentially to the spectral data by \code{procspec}.

<<results=hide>>=
# Run some different normalizations
specs.max <- procspec(sppspec, opt='max')
specs.min <- procspec(sppspec, opt='min')
specs.str <- procspec(sppspec, opt=c('min', 'max'))  # multiple options
@

<<label=specnorm,fig=TRUE,include=FALSE,width=7,height=2.7>>=
# plot results
par(mfrow=c(1,3), mar=c(2,2,2,2), oma=c(2,2,0,0))
plot(specs.max[, 5]~c(300:700), ylim=c(0,1), xlab="", ylab="", type='l')
abline(h=1, lty=2)
plot(specs.min[,5]~c(300:700), xlab="", ylab="", type='l')
abline(h=0, lty=2)
plot(specs.str[,5]~c(300:700), type='l', xlab="", ylab="")
abline(h=c(0,1), lty=2)
mtext("Wavelength (nm)", side=1, outer=T, line=1)
mtext("Reflectance (%)", side=2, outer=T, line=1)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=6in]{pavo-specnorm}
\end{center}
\caption{Results for max (left), min (center), and max and min normalizations (right).}
\label{figure:specnorm}
\end{figure}


Another intended usage of \code{procspec} is preparation of spectral data for variable reduction
(PCA). Following Cuthill, 1999 we can use \code{opt} = 'center' and 'bin' to center spectra to have
a mean reflectance of zero (thus removing brightness as a dominant variable? in a PCA) and then bin
the spectra into user-defined bins (using the \code{bins} argument) and obtain a dataframe suitable
for a principle component analysis (PCA).

<<results=hide>>=
# pca analysis
specs.bin <- procspec(sppspec, opt=c('bin', 'center'))
specs.bin <- t(specs.bin)  # transpose so specs in rows
colnames(specs.bin) <- specs.bin[1,]  # names variables as wavelength bins
specs.bin <- specs.bin[-1, ]  # remove 'wl' column
# specs.bin[1:6, 1:3]
pca1 <- prcomp(specs.bin, scale=T)
@

The flexibility of \code{pavo}'s plotting capabilities allows you to sort spectra by another
variable (e.g., PC1 loading) and then plot in a stacked format using the \code{plot.rspec} function.

<<label=pcaplot,fig=TRUE,include=FALSE,width=8,height=4>>=
# generate colors from spectra
colr <- spec2rgb(sppspec)
wls <- as.numeric(colnames(specs.bin))
# rank specs by PC1
sel <- rank(pca1$x[,1])
sel <- match(names(sort(sel)), names(sppspec))
# plot results
par(mfrow=c(1,2), mar=c(2,4,2,2), oma=c(2,0,0,0))
plot(pca1$r[,1]~wls, type='l', ylab="PC1 loading")
abline(h=0, lty=2)
plot(sppspec, sel, type='s', col=spec2rgb(sppspec))
mtext("Wavelength (nm)", side=1, outer=T, line=1)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=5in]{pavo-pcaplot}
\end{center}
\caption{Plot of PC1 loading versus wavelength (left) and species mean spectra sorted vertically 
from lowest to highest PC1 value (right).}
\label{figure:pcaplot}
\end{figure}

\section{Visualizing Spectral Data}

The function \code{plot.rspec} can be called simply by typing \code{plot(rspecs)}, as it relies on
the base plotting capabilities. If the object is not of class \code{rspec} the multivariate
visualization methods will not work as expected.

We have implemented three methods of visualizing spectral data:

\begin{itemize}
	\item{Overlay - all spectra plotted with same x- and y-axis}
	\item{Stack - spectra plotted with same x-axis but arranged vertically along y-axis}
	\item{Heatmap - false color map to show three dimensional data}
\end{itemize}

We will first load some reflectance data. 

% <<>>=
% data(teal)  # TODO add this
% dim(teal)
% @

This dataset consists of reflectance spectra measured from the iridescent wing patch of a green-
winged teal (\emph{Anas carolinensis}). Reflectance measurements were taken between 300 and 700 nm
at different incident angles, ranging from 15 to 70 degrees (in 5 degree increments). 

We can start out by visualizing these spectra with \code{overlay} option in plot.rspec.

<<label=overlay,fig=T,include=F>>=
par(mar=c(4,4,2,2))
teal <- readRDS('~/github/pavo/toydata/teal.rda')
#teal <- loadRDS(...)[,-14]
plot(teal[, -14], type='o', col=spec2rgb(teal))
@

Another option is the \code{stack} plot.

<<label=stack,fig=T,include=F>>=
teal.norm <- procspec(teal, opt=c('min', 'max'))
par(mfrow=c(1,2))
plot(teal[, -14], type='s', col=spec2rgb(teal))
plot(teal.norm[, -14], type='s', col=spec2rgb(teal))
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{pavo-stack}
\end{center}
\caption{Stack plot}
\label{figure:overlay}
\end{figure}

Since this dataset is three-dimensional (containing wavelengths, reflectance values and incident
angles) we can also use the \code{heatmap} function. First, it will be necessary to define a vector
for the incident angles each spectrum was measured at:

<<>>=
angles <- seq(15,70,by=5)
@

 Next, we will smooth the data with \code{procspec} and plot as a false color map (heamap):
 
<<label=heatmap,fig=T,include=F>>=
teal.sm <- procspec(teal, opt=c('smooth'))
plot(teal.sm[, -14], type='h', varying=angles, ylab="Incident angle (ยบ)", las=1)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{pavo-heatmap}
\end{center}
\caption{Overlay plot with colors calculated from human color matching functions}
\label{figure:overlay}
\end{figure}

Colors can be mapped to spectra using \code{spec2rgb} as shown in Figure \ref{figure:overlay}.


\section{Analyzing Spectral Data}

\subsection{Overview}

\pavo{} offers two main approaches for spectral data analysis. First, variables can be  calculated
based on the shape of the reflectance spectra. By using special R classes for spectra  data frame
objects, this can easily be done using the \code{summary} function in an rspec  object (see below).
The second function for spectral shape analysis is \code{peakshape}, which returns descriptors for
peaks in spectral curves, as outlined below.

Second, reflectance spectra can be analyzed accounting for the visual system receiving the color
signal, therefore representing reflectance spectra as preceived colors. We have implemented
Endler's (REF) segment analysis model, which approximates visual models but does not directly  use
sensory information; the model of Osorio \& Vorobyev (REF), which provides a flexible  framework for
visual modeling; and the tetrahedral color space (GOLDSMITH, ENDLER, STODDARD)  which has been
extensively developed to represent colors in the avian vision color space.

\subsection{Spectral Shape Analysis}

\subsubsection{Trichromatic variables}

Obtaining trichromatic color variables (related to hue, saturation and value) is pretty
straightforward in \pavo{}. Since reflectance spectra is stored in an object of class  \code{rspec},
the \code{summary} function recognizes the object as such and extracts 23  variables, as outlined in
MONTGOMERIE. Though outlined in a book chapter on bird coloration,  these variables are broadly
applicable to any reflectance data, particularly if the taxon of  interest has color vision within
the UV-human visible range.

The description and formulas for these variables can be found in Table \ref{table:tristim}.

<<>>=
summary(sppspec)
@


% A table for filling in Montgomerie's color variables
\begin{table}
\begin{center}
\begin{tabular}{l l l} \hline
{\bf Color} & \\
{\bf Variable} & {\bf Equation} & {\bf Description} \\ 
\hline
\code{B1} & {$\sum_{\lambda={300}}^{700} R_\lambda$} & \parbox[t]{3in}{Total brightness, total reflectance}  \\
\code{B2} & {$B_\text{1}/n_\text{wl}$} & \parbox[t]{3in}{Mean brightness.} \\
\code{B3} & {$R_\text{max}$} & \parbox[t]{3in}{Intensity.} \\
\code{S1} & {} & \parbox[t]{3in}{Chroma, spectral purity.} \\
\code{S2} & {$R_\text{max}/R_\text{min}$} & \parbox[t]{3in}{Spectral saturation} \\
\code{S3} & {} & \parbox[t]{3in}{} \\
\code{S4} & {} & \parbox[t]{3in}{} \\
\code{S5} & {} & \parbox[t]{3in}{} \\
\code{S6} & {} & \parbox[t]{3in}{} \\
\code{S7} & {} & \parbox[t]{3in}{} \\
\code{S8} & {} & \parbox[t]{3in}{} \\
\code{S9} & {} & \parbox[t]{3in}{} \\
\code{S10} & {} & \parbox[t]{3in}{} \\
\code{H1} & {$\lambda_\text{Rmax}$} & \parbox[t]{3in}{Hue: wavelength of peak reflectance} \\
\code{H2} & {} & \parbox[t]{3in}{} \\
\code{H3} & {} & \parbox[t]{3in}{} \\
\code{H4} & {} & \parbox[t]{3in}{} \\
\code{H5} & {} & \parbox[t]{3in}{} \\
\hline
\end{tabular}
\end{center}
\caption{\label{table:tristim}
The complete set of tristimulus variables calculated by \code{summary} in \pavo{}}
\end{table}

\clearpage{}

\subsubsection{Peak shape descriptors}

Particularly in cases of reflectance spectra that have a single, discrete peak, it might be useful
to obtain variables that describe that peak's properties. The \code{peakshape} function identifies
the peak location (\code{H1}),  returns the reflectance at that point (\code{B3}), and identifies
the wavelengths at which the reflectance is half that at the peak, calculating the wavelength
bandwith of that interval (the \textbf{Full Width at Half Maximum}, or \code{FWHM}). The function
also returns the half widths, which are useful when the peaks are located near the edge of the
measurement limit and half maximum reflectance can only be reliably estimated from one of its sides.

If this all sounds too esoteric, fear not: \code{peakshape} has the option of returning plots
indicating what it's calculating. The vertical continuous red line indicates the peak location, the
horizontal continuous red line indicates the half-maximum reflectance, and the distance between the
dashed lines is the FWHM:

<<label=fwhm, fig=TRUE, include=FALSE>>=
par(mfrow=c(2,3),mar = c(5, 4, 0.5, 0.5) + 0.1)
peakshape(sppspec, plot=T)
@

\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=5in]{pavo-fwhm}
\end{center}
\caption{Plots from \code{peakshape}}
\label{figure:fwhm}
\end{figure}

As it can be seen, the variable is meaningless if the curve doesn't have a clear peak. Sometimes ,
such as in the case of the Cardinal (Figure \ref{figure:fwhm}, first panel), there might be a  peak
which is not the point of maximum reflectance of the entire spectral curve. The half-width  can also
be erroneously calculated when there are two peaks, as can be seen in the case of the  Tanager
(Figure \ref{figure:fwhm}, last panel). In this case, it's useful to set bounds when  calculating
the FWHM, using the \code{bounds} argument. \code{peakshape} also offers a  \code{select} argument
to facilitate subsetting the spectra data frame:

<<label=fwhm2, fig=TRUE, include=FALSE>>=
peakshape(sppspec, select=2, bounds=c(300,500), plot=T)
@


\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=3in]{pavo-fwhm2}
\end{center}
\caption{Plot from \code{peakshape}, setting the bounds to 300-500nm}
\label{figure:fwhm2}
\end{figure}


\section*{Examples}


<<label=fig1, fig=TRUE, include=FALSE>>=
hist(rnorm(50))
@


\subsection{Segment Classification Model}

<<label=segplot, fig=TRUE, include=FALSE, width=6, height=4>>=
fakedata1 <-  sapply(seq(100,500,by=20), 
                     function(x) rowSums(cbind(dnorm(300:700,x,30), dnorm(300:700,x+400,30))))

fakedata2 <- sapply(c(500, 300, 150, 105, 75, 55, 40, 30), 
                     function(x) dnorm(300:700,550,x))

fakedata.c <- data.frame(wl=300:700, fakedata1, fakedata2)
fakedata.c <- as.rspec(fakedata.c)
fakedata.c <- procspec(fakedata.c, "max")
seg.fdc <- segclass(fakedata.c)

fakedata1 <- as.rspec(data.frame(wl=300:700,fakedata1))
fakedata1 <- procspec(fakedata1, "max")
fakedata2 <- as.rspec(data.frame(wl=300:700,fakedata2))
fakedata2 <- procspec(fakedata2, "max")

layout(cbind(1,2,3), widths=c(1,1,3))
par(mar=c(5,4,2,0.5))
plot(fakedata1, type='stack', col=spec2rgb(fakedata1)) 
par(mar=c(5,2.5,2,1.5))
plot(fakedata2, type='stack', col=spec2rgb(fakedata2)) 
par(mar=c(5,4,2,0.5))
plot(seg.fdc, pch=20, cex=3, col=spec2rgb(fakedata.c))
@

\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=5in]{pavo-segplot}
\end{center}
\caption{Idealized reflectance spectra and their projection on the axes of segment classification}
\label{figure:segplot}
\end{figure}

\subsection*{More examples}

Some more examples:

\bibliography{}

\end{document}