#' Peak shape descriptors
#'
#' Calculates height, location and width of peak at the reflectance midpoint (FWHM).
#' Note: bounds should be set wide enough to incorporate all minima in spectra. Smoothing
#' spectra using \code{procspec} is also recommended.

#' @param specs (required) an \code{rspec} object containing spectra to process
#' @param select specification of which spectra to plot. Can be a numeric vector or 
#' factor (e.g., \code{sex=='male'})
#' @param bounds a vector specifying the wavelength range to analyze
#' @return a data frame containing peak height (max value), location (hue) and full width
#' at half maximum
#' @export
#' @examples \dontrun{
#' data(sicalis)
#' sicalis.sm <- procspec(sicalis, opt='smooth', span=.25)
#' FWHM(sicalis.sm, select=2:5, bounds=c(300, 550))}
#' @author Chad Eliason \email{cme16@@zips.uakron.edu}

peakshape <- function(specs, select = NULL, bounds = c(300, 700), plot = T, ...) {

old.par <- par(no.readonly = TRUE)  # all par settings that could be set

nms <- names(specs)

wl_index <- which(names(specs)=='wl')
if (length(wl_index) > 0) {
  haswl <- TRUE
  wl <- specs[, wl_index]
} else {
  haswl <- FALSE
  wl <- 1:nrow(specs)
  warning('No wavelengths provided; using arbitrary index values')
}

# subset based on indexing vector
if (is.logical(select))
  select <- which(select=='TRUE')
if (is.null(select)&haswl==TRUE)
  select <- (1:ncol(specs))[-wl_index]
if (is.null(select)&haswl==FALSE)
  select <- 1:ncol(specs)

specs <- as.data.frame(specs[, select])


wlrange <- bounds[1]:bounds[2]

if (ncol(specs)==1) {
  specs2 <- specs[(which(wl==bounds[1])):(which(wl==bounds[2])), ]  # working wl range
  Yi <- max(specs2)  # max refls
  Yj <- min(specs2)  # min refls
  Xi <- which(specs2==Yi)  # lambda_max index
  fsthalf <- specs2[1:Xi]
  sndhalf <- specs2[Xi:length(specs2)]
  halfmax <- (Yi + Yj) / 2  # reflectance midpoint
  fstHM <- which.min(abs(fsthalf - halfmax))
  sndHM <- which.min(abs(sndhalf - halfmax))
} else {
  specs2 <- specs[(which(wl==bounds[1])):(which(wl==bounds[2])), ]  # working wl range
  Yi <- apply(specs2, 2, max)  # max refls
  Yj <- apply(specs2, 2, min)  # min refls
  Yk <- apply(specs, 2, min)  # min refls, whole spectrum
  Xi <- sapply(1:ncol(specs2), function(x) which(specs2[, x]==Yi[x]))  # lambda_max index
  fsthalf <- sapply(1:ncol(specs2), function(x) specs2[1:Xi[x], x])
  sndhalf <- sapply(1:ncol(specs2), function(x) specs2[Xi[x]:nrow(specs2), x])
  halfmax <- (Yi + Yj) / 2  # reflectance midpoint
  fstHM <- sapply(1:length(fsthalf), function(x) which.min(abs(fsthalf[[x]]-halfmax[x])))
  sndHM <- sapply(1:length(fsthalf), function(x) which.min(abs(sndhalf[[x]]-halfmax[x])))
}


#if (any(Yj>Yk)) {
#warning(paste('Please fix bounds in spectrum', which(Yj>Yk), 'to incorporate all minima in spectral curves'))
#}

Xa <- wlrange[fstHM]
Xb <- wlrange[Xi+sndHM]
hue <- wlrange[Xi]

if (plot==TRUE) {
  for (i in seq_along(select)) {
    plot(specs[, i]~wl, type = 'l', xlab = "Wavelength (nm)", ylab = "Reflectance (%)",
         ...)
    abline(v = hue[i], col = "red")
    abline(h = halfmax[i], col = "red")
    abline(v = Xa[i], col = "red", lty = 2)
    abline(v = Xb[i], col = "red", lty = 2)
  }
}

out <- data.frame(B3 = as.numeric(Yi), H1 = hue, FWHM = Xb - Xa)

row.names(out) <- nms[select]

out

}
